# Vortex ì—”ì§„ ì¬ì„¤ê³„ ê³„íšì„œ

## ğŸ“‹ ëª©ì°¨
1. [ë¬¸ì œ ì§„ë‹¨](#1-ë¬¸ì œ-ì§„ë‹¨)
2. [ì¬ì„¤ê³„ ëª©í‘œ](#2-ì¬ì„¤ê³„-ëª©í‘œ)
3. [ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜](#3-ìƒˆë¡œìš´-ì•„í‚¤í…ì²˜)
4. [êµ¬í˜„ ë‹¨ê³„](#4-êµ¬í˜„-ë‹¨ê³„)
5. [ì½”ë“œ ì˜ˆì‹œ](#5-ì½”ë“œ-ì˜ˆì‹œ)
6. [ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´í¬ë¦¬ìŠ¤íŠ¸](#6-ë§ˆì´ê·¸ë ˆì´ì…˜-ì²´í¬ë¦¬ìŠ¤íŠ¸)

---

## 1. ë¬¸ì œ ì§„ë‹¨

### í˜„ì¬ êµ¬ì¡°ì˜ í•µì‹¬ ë¬¸ì œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        CallAcceptAccessibilityService           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Auto Refresh  â”‚      â”‚  processNode()   â”‚  â”‚
â”‚  â”‚  (5ì´ˆ íƒ€ì´ë¨¸)  â”‚      â”‚ (ì´ë²¤íŠ¸ ê¸°ë°˜)     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚          â”‚                       â”‚             â”‚
â”‚          â–¼                       â–¼             â”‚
â”‚   ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­        ìƒíƒœ ë¨¸ì‹  ì‹¤í–‰      â”‚
â”‚          â”‚                       â”‚             â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                  âŒ ë¶„ë¦¬ë¨                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ë¬¸ì œì :**
1. âŒ **ìƒˆë¡œê³ ì¹¨ê³¼ ìƒíƒœ ë¨¸ì‹ ì´ ë¶„ë¦¬**ë˜ì–´ ì¡°ìœ¨ ë¶ˆê°€
2. âŒ **ê³ ì • 5ì´ˆ ê°„ê²©** - ìƒí™©ì— ë§ëŠ” ë™ì  ì¡°ì • ë¶ˆê°€
3. âŒ **ì´ë²¤íŠ¸ ì˜ì¡´ì ** - ëŠ¥ë™ì ì¸ ìƒíƒœ í™•ì¸ ë¶ˆê°€
4. âŒ **ë©”ì¸ ë£¨í”„ ì—†ìŒ** - ìë™ ì¬ì‹¤í–‰ ë©”ì»¤ë‹ˆì¦˜ ì—†ìŒ

---

## 2. ì¬ì„¤ê³„ ëª©í‘œ

### ì›ë³¸ APKì˜ í•µì‹¬ ì›ë¦¬ ë³µì›

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CallAcceptEngineImpl                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚        startMacroLoop()              â”‚      â”‚
â”‚   â”‚  (ìê¸° ìì‹ ì„ ì¬ê·€ í˜¸ì¶œí•˜ëŠ” ë¬´í•œ ë£¨í”„)  â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚              â”‚                                   â”‚
â”‚              â–¼                                   â”‚
â”‚   executeStateMachineOnce()                     â”‚
â”‚              â”‚                                   â”‚
â”‚              â”œâ”€ WAITING_FOR_CALL                â”‚
â”‚              â”‚  â””â”€ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ (5ì´ˆë§ˆë‹¤)  â”‚
â”‚              â”‚                                   â”‚
â”‚              â”œâ”€ DETECTED_CALL                   â”‚
â”‚              â”‚  â””â”€ ì½œ ë¶„ì„ (50ms)                â”‚
â”‚              â”‚                                   â”‚
â”‚              â”œâ”€ ACCEPTING_CALL                  â”‚
â”‚              â”‚  â””â”€ ìˆ˜ë½ ë²„íŠ¼ í´ë¦­ (10ms)         â”‚
â”‚              â”‚                                   â”‚
â”‚              â–¼                                   â”‚
â”‚   scheduleNext(delayMs) â†’ startMacroLoop()      â”‚
â”‚              â”‚                                   â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚                           â–¼                     â”‚
â”‚               Handler.postDelayed()             â”‚
â”‚                           â”‚                     â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚              â–¼                                   â”‚
â”‚   delayMs í›„ startMacroLoop() ì¬ì‹¤í–‰           â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ëª©í‘œ:**
1. âœ… **ë©”ì¸ ë£¨í”„ êµ¬í˜„**: ìê¸° ìì‹ ì„ ì¬ê·€ í˜¸ì¶œ
2. âœ… **ìƒíƒœ ë¨¸ì‹  í†µí•©**: ìƒˆë¡œê³ ì¹¨ì„ ìƒíƒœ ë¨¸ì‹  ë‚´ë¶€ë¡œ
3. âœ… **ë™ì  ì§€ì—° ì‹œê°„**: ìƒíƒœë³„ ìµœì í™”ëœ ê°„ê²©
4. âœ… **ëŠ¥ë™ì  ì‹¤í–‰**: ì´ë²¤íŠ¸ ì—†ì´ë„ ì£¼ê¸°ì  ì‹¤í–‰

---

## 3. ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜

### 3.1 í•µì‹¬ ì»´í¬ë„ŒíŠ¸

#### A. CallAcceptEngineImpl (ì¬ì„¤ê³„)

**ì—­í• :**
- ë©”ì¸ ë£¨í”„ ì‹¤í–‰ (`startMacroLoop()`)
- ìƒíƒœ ë¨¸ì‹  ì¡°ìœ¨ (`executeStateMachineOnce()`)
- ìŠ¤ì¼€ì¤„ë§ ê´€ë¦¬ (`scheduleNext()`)
- ìƒˆë¡œê³ ì¹¨ íƒ€ì´ë° ì œì–´

**ìƒˆë¡œìš´ í•„ë“œ:**
```kotlin
private val handler = Handler(Looper.getMainLooper())
private var currentRunnable: Runnable? = null
private var lastRefreshTime = 0L
private val refreshDelay = 5.0f  // ì´ˆ ë‹¨ìœ„
```

**ìƒˆë¡œìš´ ë©”ì„œë“œ:**
```kotlin
// 1. ë©”ì¸ ë£¨í”„ (í•µì‹¬!)
private fun startMacroLoop()

// 2. ìƒíƒœ ë¨¸ì‹  í•œ ë²ˆ ì‹¤í–‰ (ë°˜í™˜: ë‹¤ìŒ ì§€ì—° ì‹œê°„)
private fun executeStateMachineOnce(): Long

// 3. ë‹¤ìŒ ì‹¤í–‰ ì˜ˆì•½
private fun scheduleNext(delayMs: Long, action: () -> Unit)

// 4. ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­
private fun performRefresh(rootNode: AccessibilityNodeInfo)

// 5. ìƒˆë¡œê³ ì¹¨ ì§€ì—° ì‹œê°„ ê³„ì‚°
private fun calculateRefreshDelay(): Long
```

#### B. CallAcceptAccessibilityService (ë‹¨ìˆœí™”)

**ì—­í• :**
- ì—”ì§„ì— rootNode ì œê³µë§Œ
- ìì²´ íƒ€ì´ë¨¸ ì œê±°
- ì´ë²¤íŠ¸ ì „ë‹¬ë§Œ ë‹´ë‹¹

**ì œê±°í•  ê²ƒ:**
- `startAutoRefresh()` ì‚­ì œ
- `stopAutoRefresh()` ì‚­ì œ
- `performRefresh()` ì‚­ì œ
- `refreshHandler` ì‚­ì œ

**ìœ ì§€í•  ê²ƒ:**
```kotlin
override fun onAccessibilityEvent(event: AccessibilityEvent?) {
    rootInActiveWindow?.let { rootNode ->
        // ë‹¨ìˆœíˆ rootNodeë§Œ ì „ë‹¬
        engine.processNode(rootNode)
    }
}
```

#### C. StateHandler (ìˆ˜ì •)

**ê¸°ì¡´:**
```kotlin
interface StateHandler {
    val targetState: CallAcceptState
    fun handle(node: AccessibilityNodeInfo, context: StateContext): StateResult
}
```

**ì¶”ê°€:**
```kotlin
interface StateHandler {
    val targetState: CallAcceptState

    // ê¸°ì¡´ ë©”ì„œë“œ
    fun handle(node: AccessibilityNodeInfo, context: StateContext): StateResult

    // ìƒˆ ë©”ì„œë“œ: ì´ ìƒíƒœì˜ ë‹¤ìŒ ì‹¤í–‰ ì§€ì—° ì‹œê°„ ë°˜í™˜
    fun getNextDelay(): Long
}
```

---

## 4. êµ¬í˜„ ë‹¨ê³„

### Phase 1: ì—”ì§„ì— ë©”ì¸ ë£¨í”„ ì¶”ê°€ (ìš°ì„ ìˆœìœ„: ìµœê³ )

**íŒŒì¼:** `CallAcceptEngineImpl.kt`

**ëª©í‘œ:** ìê¸° ìì‹ ì„ ì¬ê·€ í˜¸ì¶œí•˜ëŠ” ë¬´í•œ ë£¨í”„ êµ¬í˜„

**ë‹¨ê³„:**
1. Handlerì™€ Runnable í•„ë“œ ì¶”ê°€
2. `startMacroLoop()` ë©”ì„œë“œ êµ¬í˜„
3. `scheduleNext()` ë©”ì„œë“œ êµ¬í˜„
4. `start()` ë©”ì„œë“œì—ì„œ `startMacroLoop()` í˜¸ì¶œ
5. `stop()` ë©”ì„œë“œì—ì„œ ìŠ¤ì¼€ì¤„ ì·¨ì†Œ

**ì˜ˆìƒ ì‹œê°„:** 1ì‹œê°„

---

### Phase 2: ìƒíƒœë³„ ì§€ì—° ì‹œê°„ êµ¬í˜„ (ìš°ì„ ìˆœìœ„: ë†’ìŒ)

**íŒŒì¼:** `CallAcceptEngineImpl.kt`, ëª¨ë“  Handler í´ë˜ìŠ¤

**ëª©í‘œ:** ê° ìƒíƒœë§ˆë‹¤ ìµœì í™”ëœ ì§€ì—° ì‹œê°„ ë°˜í™˜

**ë‹¨ê³„:**
1. `StateHandler` ì¸í„°í˜ì´ìŠ¤ì— `getNextDelay()` ì¶”ê°€
2. ê° í•¸ë“¤ëŸ¬ì— ì§€ì—° ì‹œê°„ êµ¬í˜„:
   - `IdleHandler`: null (ë£¨í”„ ì¤‘ì§€)
   - `CallListHandler`: ë™ì  ê³„ì‚° (4500~5500ms)
   - `DetectedCallHandler`: 50ms
   - `WaitingForConfirmHandler`: 10ms
   - ê¸°íƒ€: ì ì ˆí•œ ê°’

**ì˜ˆìƒ ì‹œê°„:** 30ë¶„

---

### Phase 3: ìƒˆë¡œê³ ì¹¨ ë¡œì§ í†µí•© (ìš°ì„ ìˆœìœ„: ìµœê³ )

**íŒŒì¼:** `CallListHandler.kt`, `CallAcceptEngineImpl.kt`

**ëª©í‘œ:** ìƒˆë¡œê³ ì¹¨ì„ ìƒíƒœ ë¨¸ì‹  ë‚´ë¶€ë¡œ ì´ë™

**ë°©ë²• A: ì—”ì§„ì—ì„œ ì§ì ‘ ì²˜ë¦¬ (ê¶Œì¥)**
```kotlin
// CallAcceptEngineImpl.kt
private fun executeStateMachineOnce(rootNode: AccessibilityNodeInfo): Long {
    // WAITING_FOR_CALL ìƒíƒœì¼ ë•Œë§Œ ìƒˆë¡œê³ ì¹¨ í™•ì¸
    if (_currentState.value == CallAcceptState.WAITING_FOR_CALL) {
        val elapsedSinceRefresh = System.currentTimeMillis() - lastRefreshTime
        val refreshDelay = calculateRefreshDelay()

        if (elapsedSinceRefresh >= refreshDelay) {
            // ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­
            performRefresh(rootNode)
            lastRefreshTime = System.currentTimeMillis()
            return 30L  // 30ms í›„ ë‹¤ì‹œ í™•ì¸
        } else {
            // ì•„ì§ ì‹œê°„ ì•ˆë¨, ë‚¨ì€ ì‹œê°„ë§Œí¼ ëŒ€ê¸°
            return refreshDelay - elapsedSinceRefresh
        }
    }

    // ë‹¤ë¥¸ ìƒíƒœëŠ” í•¸ë“¤ëŸ¬ì—ê²Œ ìœ„ì„
    val handler = handlerMap[_currentState.value] ?: return 100L
    // ...
}
```

**ë°©ë²• B: CallListHandlerì—ì„œ ì²˜ë¦¬**
```kotlin
// CallListHandler.kt
override fun handle(node: AccessibilityNodeInfo, context: StateContext): StateResult {
    // 1. ìƒˆë¡œê³ ì¹¨ í•„ìš” ì—¬ë¶€ í™•ì¸
    if (shouldRefresh(context)) {
        clickRefreshButton(node)
        context.updateLastRefreshTime()
        return StateResult.NoChange  // 30ms í›„ ë‹¤ì‹œ í™•ì¸
    }

    // 2. ì½œ ë¦¬ìŠ¤íŠ¸ ë¶„ì„
    val calls = parseReservationCalls(node, context)
    // ...
}
```

**ê¶Œì¥:** ë°©ë²• A (ì—”ì§„ì—ì„œ ì§ì ‘)
- ìƒˆë¡œê³ ì¹¨ì€ ìƒíƒœì™€ ë¬´ê´€í•œ ê¸€ë¡œë²Œ ë™ì‘
- ëª¨ë“  í•¸ë“¤ëŸ¬ê°€ ì‹ ê²½ ì“¸ í•„ìš” ì—†ìŒ

**ì˜ˆìƒ ì‹œê°„:** 1ì‹œê°„

---

### Phase 4: AccessibilityService ë‹¨ìˆœí™” (ìš°ì„ ìˆœìœ„: ì¤‘ê°„)

**íŒŒì¼:** `CallAcceptAccessibilityService.kt`

**ëª©í‘œ:** íƒ€ì´ë¨¸ ì œê±°, rootNode ì „ë‹¬ë§Œ

**ë‹¨ê³„:**
1. `refreshHandler` í•„ë“œ ì‚­ì œ
2. `startAutoRefresh()` ë©”ì„œë“œ ì‚­ì œ
3. `stopAutoRefresh()` ë©”ì„œë“œ ì‚­ì œ
4. `performRefresh()` ë©”ì„œë“œ ì‚­ì œ
5. `observeEngineState()` ë©”ì„œë“œ ì‚­ì œ
6. `onAccessibilityEvent()`ë§Œ ë‚¨ê¸°ê¸°

**ì˜ˆìƒ ì‹œê°„:** 30ë¶„

---

### Phase 5: StateContextì— rootNode ì „ë‹¬ (ìš°ì„ ìˆœìœ„: ë†’ìŒ)

**íŒŒì¼:** `StateContext.kt`, `CallAcceptEngineImpl.kt`

**ëª©í‘œ:** í•¸ë“¤ëŸ¬ê°€ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì„ í´ë¦­í•  ìˆ˜ ìˆë„ë¡

**ë³€ê²½:**
```kotlin
// ê¸°ì¡´
data class StateContext(
    val findNode: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val findNodeByText: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val logger: ILogger,
    val filterSettings: IFilterSettings,
    val timeSettings: ITimeSettings
)

// ìƒˆë¡œìš´
data class StateContext(
    val rootNode: AccessibilityNodeInfo,  // â† ì¶”ê°€!
    val findNode: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val findNodeByText: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val logger: ILogger,
    val filterSettings: IFilterSettings,
    val timeSettings: ITimeSettings,
    var lastRefreshTime: Long  // â† ì¶”ê°€!
) {
    // ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ í—¬í¼
    fun clickRefreshButton(): Boolean {
        val refreshButton = rootNode.findAccessibilityNodeInfosByViewId(
            "com.kakao.taxi.driver:id/action_refresh"
        ).firstOrNull()

        return refreshButton?.performAction(
            AccessibilityNodeInfo.ACTION_CLICK
        ) ?: false
    }
}
```

**ì˜ˆìƒ ì‹œê°„:** 30ë¶„

---

### Phase 6: í…ŒìŠ¤íŠ¸ ë° ë””ë²„ê¹… (ìš°ì„ ìˆœìœ„: í•„ìˆ˜)

**ëª©í‘œ:** ì‹¤ì œ ì•±ì—ì„œ ì‘ë™ í™•ì¸

**ì²´í¬ë¦¬ìŠ¤íŠ¸:**
- [ ] ë©”ì¸ ë£¨í”„ê°€ ìë™ ì¬ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì´ 5ì´ˆë§ˆë‹¤ í´ë¦­ë˜ëŠ”ê°€?
- [ ] ì½œ ë¦¬ìŠ¤íŠ¸ê°€ íŒŒì‹±ë˜ëŠ”ê°€?
- [ ] ìƒíƒœ ì „í™˜ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë¡œê·¸ê°€ ì˜¬ë°”ë¥´ê²Œ ì¶œë ¥ë˜ëŠ”ê°€?

**ì˜ˆìƒ ì‹œê°„:** 2ì‹œê°„

---

## 5. ì½”ë“œ ì˜ˆì‹œ

### 5.1 CallAcceptEngineImpl (ì™„ì „í•œ êµ¬í˜„)

```kotlin
@Singleton
class CallAcceptEngineImpl @Inject constructor(
    private val logger: ILogger,
    private val filterSettings: IFilterSettings,
    private val timeSettings: ITimeSettings,
    private val handlers: Set<@JvmSuppressWildcards StateHandler>
) : ICallEngine {

    companion object {
        private const val TAG = "CallAcceptEngineImpl"
        private const val TIMEOUT_MS = 10000L
        private const val REFRESH_BUTTON_ID = "com.kakao.taxi.driver:id/action_refresh"
    }

    private val _currentState = MutableStateFlow(CallAcceptState.IDLE)
    override val currentState: StateFlow<CallAcceptState> = _currentState.asStateFlow()

    private val _isRunning = MutableStateFlow(false)
    override val isRunning: StateFlow<Boolean> = _isRunning.asStateFlow()

    // ============================================
    // ìƒˆë¡œ ì¶”ê°€: ë©”ì¸ ë£¨í”„ ê´€ë ¨ í•„ë“œ
    // ============================================
    private val handler = Handler(Looper.getMainLooper())
    private var currentRunnable: Runnable? = null
    private var lastRefreshTime = 0L
    private var cachedRootNode: AccessibilityNodeInfo? = null

    // ì„¤ì •ê°’ (ë‚˜ì¤‘ì— SettingsManagerì—ì„œ ê°€ì ¸ì˜¤ê¸°)
    private val refreshDelay = 5.0f  // ì´ˆ ë‹¨ìœ„

    private val handlerMap: Map<CallAcceptState, StateHandler> by lazy {
        handlers.associateBy { it.targetState }
    }

    private val stateContext: StateContext by lazy {
        StateContext(
            rootNode = cachedRootNode!!,  // ì‹¤í–‰ ì‹œ ì—…ë°ì´íŠ¸ë¨
            findNode = ::findNodeByViewId,
            findNodeByText = ::findNodeByText,
            logger = logger,
            filterSettings = filterSettings,
            timeSettings = timeSettings,
            lastRefreshTime = 0L
        )
    }

    // ============================================
    // ê¸°ì¡´ ë©”ì„œë“œ (ìˆ˜ì •)
    // ============================================

    override fun start() {
        if (_isRunning.value) return
        Log.d(TAG, "ì—”ì§„ ì‹œì‘")
        _isRunning.value = true
        changeState(CallAcceptState.WAITING_FOR_CALL, "ì—”ì§„ ì‹œì‘ë¨")

        // ë©”ì¸ ë£¨í”„ ì‹œì‘ â† í•µì‹¬!
        startMacroLoop()
    }

    override fun stop() {
        if (!_isRunning.value) return
        Log.d(TAG, "ì—”ì§„ ì •ì§€")
        _isRunning.value = false

        // ìŠ¤ì¼€ì¤„ëœ ì‘ì—… ì·¨ì†Œ
        currentRunnable?.let { handler.removeCallbacks(it) }
        currentRunnable = null

        changeState(CallAcceptState.IDLE, "ì—”ì§„ ì •ì§€ë¨")
    }

    override fun processNode(node: AccessibilityNodeInfo) {
        // rootNode ì—…ë°ì´íŠ¸ (ë©”ì¸ ë£¨í”„ì—ì„œ ì‚¬ìš©)
        cachedRootNode = node
    }

    // ============================================
    // ìƒˆë¡œ ì¶”ê°€: ë©”ì¸ ë£¨í”„ ë©”ì„œë“œ
    // ============================================

    /**
     * ë©”ì¸ ë£¨í”„ - ìê¸° ìì‹ ì„ ì¬ê·€ í˜¸ì¶œ
     * ì›ë³¸ APKì˜ startMacroLoop() ì¬í˜„
     */
    private fun startMacroLoop() {
        // 1. ì‹¤í–‰ ì¤‘ í™•ì¸
        if (!_isRunning.value) {
            Log.d(TAG, "ë©”ì¸ ë£¨í”„ ì¤‘ë‹¨: ì—”ì§„ ì •ì§€ë¨")
            return
        }

        // 2. rootNode í™•ì¸
        val rootNode = cachedRootNode
        if (rootNode == null) {
            Log.w(TAG, "rootNodeê°€ ì—†ìŒ - 100ms í›„ ì¬ì‹œë„")
            scheduleNext(100L) { startMacroLoop() }
            return
        }

        // 3. ìƒíƒœ ë¨¸ì‹  í•œ ë²ˆ ì‹¤í–‰
        val delayMs = executeStateMachineOnce(rootNode)

        // 4. ë‹¤ìŒ ì‹¤í–‰ ì˜ˆì•½ (ì¬ê·€!)
        scheduleNext(delayMs) { startMacroLoop() }
    }

    /**
     * ìƒíƒœ ë¨¸ì‹  í•œ ë²ˆ ì‹¤í–‰
     * ì›ë³¸ APKì˜ executeStateMachineOnce() ì¬í˜„
     *
     * @return ë‹¤ìŒ ì‹¤í–‰ê¹Œì§€ì˜ ì§€ì—° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     */
    private fun executeStateMachineOnce(rootNode: AccessibilityNodeInfo): Long {
        val currentTime = System.currentTimeMillis()

        Log.v(TAG, "ìƒíƒœ ë¨¸ì‹  ì‹¤í–‰: ${_currentState.value}")

        // WAITING_FOR_CALL ìƒíƒœì—ì„œë§Œ ìƒˆë¡œê³ ì¹¨ ë¡œì§ ì‹¤í–‰
        if (_currentState.value == CallAcceptState.WAITING_FOR_CALL) {
            val elapsedSinceRefresh = currentTime - lastRefreshTime
            val targetRefreshDelay = calculateRefreshDelay()

            if (elapsedSinceRefresh >= targetRefreshDelay) {
                // ìƒˆë¡œê³ ì¹¨ ì‹œê°„ ë„ë˜
                Log.d(TAG, "ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ (ê²½ê³¼: ${elapsedSinceRefresh}ms)")
                performRefresh(rootNode)
                lastRefreshTime = currentTime
                return 30L  // 30ms í›„ ë‹¤ì‹œ í™•ì¸
            } else {
                // ì•„ì§ ì‹œê°„ ì•ˆë¨
                val remainingMs = targetRefreshDelay - elapsedSinceRefresh
                Log.v(TAG, "ìƒˆë¡œê³ ì¹¨ ëŒ€ê¸° ì¤‘ (ë‚¨ì€ ì‹œê°„: ${remainingMs}ms)")
                return remainingMs.coerceAtMost(1000L)  // ìµœëŒ€ 1ì´ˆë§ˆë‹¤ í™•ì¸
            }
        }

        // ë‹¤ë¥¸ ìƒíƒœëŠ” í•¸ë“¤ëŸ¬ì—ê²Œ ìœ„ì„
        val currentHandler = handlerMap[_currentState.value]
        if (currentHandler == null) {
            Log.w(TAG, "í•¸ë“¤ëŸ¬ ì—†ìŒ: ${_currentState.value}")
            return 100L  // ê¸°ë³¸ê°’
        }

        // StateContext ì—…ë°ì´íŠ¸
        val context = stateContext.copy(
            rootNode = rootNode,
            lastRefreshTime = lastRefreshTime
        )

        // í•¸ë“¤ëŸ¬ ì‹¤í–‰
        when (val result = currentHandler.handle(rootNode, context)) {
            is StateResult.Transition -> {
                changeState(result.nextState, result.reason)
            }
            is StateResult.Error -> {
                changeState(result.errorState, result.reason)
            }
            StateResult.NoChange -> {
                // ìƒíƒœ ìœ ì§€
            }
        }

        // ë‹¤ìŒ ì§€ì—° ì‹œê°„ ë°˜í™˜
        return currentHandler.getNextDelay()
    }

    /**
     * ë‹¤ìŒ ì‹¤í–‰ ì˜ˆì•½
     * ì›ë³¸ APKì˜ scheduleNext() ì¬í˜„
     */
    private fun scheduleNext(delayMs: Long, action: () -> Unit) {
        // 1. ê¸°ì¡´ Runnable ì œê±° (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
        currentRunnable?.let { handler.removeCallbacks(it) }

        // 2. ìƒˆ Runnable ìƒì„±
        val newRunnable = Runnable { action() }
        currentRunnable = newRunnable

        // 3. Handlerì— ë“±ë¡
        handler.postDelayed(newRunnable, delayMs)

        Log.v(TAG, "ë‹¤ìŒ ì‹¤í–‰ ì˜ˆì•½: ${delayMs}ms í›„")
    }

    /**
     * ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­
     */
    private fun performRefresh(rootNode: AccessibilityNodeInfo) {
        val startTime = System.currentTimeMillis()

        val refreshButton = rootNode.findAccessibilityNodeInfosByViewId(REFRESH_BUTTON_ID)
            .firstOrNull()

        if (refreshButton != null && refreshButton.isClickable) {
            val success = refreshButton.performAction(
                AccessibilityNodeInfo.ACTION_CLICK
            )
            val elapsedMs = System.currentTimeMillis() - startTime

            Log.d(TAG, "ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ ${if (success) "ì„±ê³µ" else "ì‹¤íŒ¨"} (${elapsedMs}ms)")

            logger.logNodeClick(
                nodeId = REFRESH_BUTTON_ID,
                success = success,
                state = CallAcceptState.WAITING_FOR_CALL,
                elapsedMs = elapsedMs
            )
        } else {
            Log.w(TAG, "ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
        }
    }

    /**
     * ìƒˆë¡œê³ ì¹¨ ì§€ì—° ì‹œê°„ ê³„ì‚°
     * ì›ë³¸ APKì²˜ëŸ¼ Â±10% ëœë¤ ì¶”ê°€
     */
    private fun calculateRefreshDelay(): Long {
        val baseDelay = (refreshDelay * 1000).toLong()
        val randomFactor = 0.9 + kotlin.random.Random.nextDouble(0.0, 0.2)
        return (baseDelay * randomFactor).toLong()
    }

    // ============================================
    // ê¸°ì¡´ ë©”ì„œë“œë“¤ (ë³€ê²½ ì—†ìŒ)
    // ============================================

    private fun changeState(newState: CallAcceptState, reason: String) {
        if (_currentState.value == newState) return

        Log.d(TAG, "ìƒíƒœ ë³€ê²½: ${_currentState.value} -> $newState (ì´ìœ : $reason)")
        _currentState.value = newState
    }

    private fun findNodeByViewId(rootNode: AccessibilityNodeInfo, viewId: String): AccessibilityNodeInfo? {
        val nodes = rootNode.findAccessibilityNodeInfosByViewId(viewId)
        return if (nodes.isNotEmpty()) nodes[0] else null
    }

    private fun findNodeByText(rootNode: AccessibilityNodeInfo, text: String): AccessibilityNodeInfo? {
        val exactNodes = rootNode.findAccessibilityNodeInfosByText(text)
        if (exactNodes.isNotEmpty()) {
            return exactNodes.firstOrNull { it.isClickable } ?: exactNodes[0]
        }
        return findClickableNodeWithText(rootNode, text)
    }

    private fun findClickableNodeWithText(node: AccessibilityNodeInfo, text: String): AccessibilityNodeInfo? {
        val nodeText = node.text?.toString() ?: ""
        if (nodeText.contains(text, ignoreCase = true) && node.isClickable) {
            return node
        }

        val contentDesc = node.contentDescription?.toString() ?: ""
        if (contentDesc.contains(text, ignoreCase = true) && node.isClickable) {
            return node
        }

        for (i in 0 until node.childCount) {
            node.getChild(i)?.let { child ->
                findClickableNodeWithText(child, text)?.let { found ->
                    return found
                }
            }
        }

        return null
    }

    override fun setAutoRefreshEnabled(enabled: Boolean) {
        // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (ì—”ì§„ì´ ì§ì ‘ ì œì–´)
        Log.d(TAG, "setAutoRefreshEnabled() í˜¸ì¶œë¨ (ë¬´ì‹œë¨)")
    }
}
```

### 5.2 StateHandler ì¸í„°í˜ì´ìŠ¤ ìˆ˜ì •

```kotlin
interface StateHandler {
    val targetState: CallAcceptState

    /**
     * ìƒíƒœ ì²˜ë¦¬
     */
    fun handle(node: AccessibilityNodeInfo, context: StateContext): StateResult

    /**
     * ì´ ìƒíƒœì˜ ë‹¤ìŒ ì‹¤í–‰ ì§€ì—° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
     *
     * ì›ë³¸ APKì˜ ì§€ì—° ì‹œê°„:
     * - IDLE: ì‹¤í–‰ ì•ˆ í•¨ (Long.MAX_VALUE)
     * - WAITING_FOR_CALL: ë™ì  ê³„ì‚° (ì—”ì§„ì—ì„œ ì²˜ë¦¬)
     * - LIST_DETECTED: 50ms
     * - ANALYZING: 50ms
     * - DETECTED_CALL: 50ms
     * - ACCEPTING_CALL: 10ms
     * - WAITING_FOR_CONFIRM: 10ms
     * - CALL_ACCEPTED: 500ms
     * - ERROR_*: 500ms
     */
    fun getNextDelay(): Long
}
```

### 5.3 ê° í•¸ë“¤ëŸ¬ì˜ getNextDelay() êµ¬í˜„ ì˜ˆì‹œ

```kotlin
// IdleHandler.kt
override fun getNextDelay(): Long = Long.MAX_VALUE  // ì‹¤í–‰ ì•ˆ í•¨

// CallListHandler.kt
override fun getNextDelay(): Long = 100L  // 100ms (ì—”ì§„ì´ ìƒˆë¡œê³ ì¹¨ ì²˜ë¦¬)

// DetectedCallHandler.kt
override fun getNextDelay(): Long = 50L  // 50ms

// WaitingForConfirmHandler.kt
override fun getNextDelay(): Long = 10L  // 10ms
```

### 5.4 StateContext ìˆ˜ì •

```kotlin
data class StateContext(
    val rootNode: AccessibilityNodeInfo,  // ì¶”ê°€
    val findNode: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val findNodeByText: (AccessibilityNodeInfo, String) -> AccessibilityNodeInfo?,
    val logger: ILogger,
    val filterSettings: IFilterSettings,
    val timeSettings: ITimeSettings,
    var lastRefreshTime: Long  // ì¶”ê°€
)
```

### 5.5 CallAcceptAccessibilityService (ë‹¨ìˆœí™”)

```kotlin
@AndroidEntryPoint
class CallAcceptAccessibilityService : AccessibilityService() {

    companion object {
        private const val TAG = "CallAcceptService"
    }

    @Inject
    lateinit var engine: ICallEngine

    @Inject
    lateinit var logger: ILogger

    override fun onServiceConnected() {
        super.onServiceConnected()
        Log.d(TAG, "ì„œë¹„ìŠ¤ ì—°ê²°ë¨")

        // ì¸ì¦ í™•ì¸
        val authManager = AuthManager.getInstance(applicationContext)
        if (!authManager.isAuthorized || !authManager.isCacheValid()) {
            Log.w(TAG, "ì¸ì¦ë˜ì§€ ì•Šì€ ì ‘ê·¼ - ì„œë¹„ìŠ¤ ë¹„í™œì„±í™”")
            Toast.makeText(applicationContext, "ì¸ì¦ë˜ì§€ ì•Šì€ ì ‘ê·¼ì…ë‹ˆë‹¤.", Toast.LENGTH_SHORT).show()
            disableSelf()
            return
        }
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        // ì¸ì¦ ì¬í™•ì¸
        val authManager = AuthManager.getInstance(applicationContext)
        if (!authManager.isAuthorized || !authManager.isCacheValid()) {
            Log.w(TAG, "ì¸ì¦ ìºì‹œ ë§Œë£Œ - ì„œë¹„ìŠ¤ ë¹„í™œì„±í™”")
            disableSelf()
            return
        }

        // í™”ë©´ ë³€ê²½ ì‹œ rootNode ì „ë‹¬
        if (event?.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED ||
            event?.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {

            rootInActiveWindow?.let { rootNode ->
                // ì—”ì§„ì— rootNode ì „ë‹¬ (ì—”ì§„ì´ ë©”ì¸ ë£¨í”„ì—ì„œ ì‚¬ìš©)
                engine.processNode(rootNode)
            }
        }
    }

    override fun onInterrupt() {
        Log.d(TAG, "ì„œë¹„ìŠ¤ ì¤‘ë‹¨")
    }

    override fun onDestroy() {
        super.onDestroy()
    }
}
```

---

## 6. ë§ˆì´ê·¸ë ˆì´ì…˜ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì¤€ë¹„ ë‹¨ê³„
- [ ] í˜„ì¬ ì½”ë“œë¥¼ ë³„ë„ ë¸Œëœì¹˜ì— ë°±ì—…
- [ ] ì¬ì„¤ê³„ ë¬¸ì„œ ì½ê³  ì´í•´
- [ ] í•„ìš”í•œ í•„ë“œ/ë©”ì„œë“œ ëª©ë¡ ì‘ì„±

### êµ¬í˜„ ë‹¨ê³„
- [ ] **Phase 1**: CallAcceptEngineImplì— ë©”ì¸ ë£¨í”„ ì¶”ê°€
  - [ ] Handler, Runnable í•„ë“œ ì¶”ê°€
  - [ ] `startMacroLoop()` êµ¬í˜„
  - [ ] `scheduleNext()` êµ¬í˜„
  - [ ] `executeStateMachineOnce()` êµ¬í˜„
  - [ ] `start()`ì—ì„œ ë©”ì¸ ë£¨í”„ ì‹œì‘
  - [ ] `stop()`ì—ì„œ ìŠ¤ì¼€ì¤„ ì·¨ì†Œ

- [ ] **Phase 2**: ìƒíƒœë³„ ì§€ì—° ì‹œê°„ êµ¬í˜„
  - [ ] `StateHandler` ì¸í„°í˜ì´ìŠ¤ì— `getNextDelay()` ì¶”ê°€
  - [ ] ëª¨ë“  í•¸ë“¤ëŸ¬ì— `getNextDelay()` êµ¬í˜„

- [ ] **Phase 3**: ìƒˆë¡œê³ ì¹¨ ë¡œì§ í†µí•©
  - [ ] `performRefresh()` ë©”ì„œë“œ êµ¬í˜„
  - [ ] `calculateRefreshDelay()` ë©”ì„œë“œ êµ¬í˜„
  - [ ] `executeStateMachineOnce()`ì— ìƒˆë¡œê³ ì¹¨ ë¡œì§ ì¶”ê°€

- [ ] **Phase 4**: AccessibilityService ë‹¨ìˆœí™”
  - [ ] íƒ€ì´ë¨¸ ê´€ë ¨ ì½”ë“œ ì œê±°
  - [ ] `onAccessibilityEvent()`ë§Œ ìœ ì§€

- [ ] **Phase 5**: StateContext ìˆ˜ì •
  - [ ] `rootNode` í•„ë“œ ì¶”ê°€
  - [ ] `lastRefreshTime` í•„ë“œ ì¶”ê°€

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„
- [ ] ë¹Œë“œ ì„±ê³µ í™•ì¸
- [ ] APK ì„¤ì¹˜ ë° ì‹¤í–‰
- [ ] ë¡œê·¸ë¡œ ë©”ì¸ ë£¨í”„ ì‘ë™ í™•ì¸
- [ ] ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­ í™•ì¸ (5ì´ˆë§ˆë‹¤)
- [ ] ì½œ ë¦¬ìŠ¤íŠ¸ íŒŒì‹± í™•ì¸
- [ ] ìƒíƒœ ì „í™˜ í™•ì¸
- [ ] ì „ì²´ í”Œë¡œìš° í…ŒìŠ¤íŠ¸

### ì™„ë£Œ í™•ì¸
- [ ] ìƒˆë¡œê³ ì¹¨ì´ ìë™ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë©”ì¸ ë£¨í”„ê°€ ê³„ì† ì‹¤í–‰ë˜ëŠ”ê°€?
- [ ] ìƒíƒœë³„ ì§€ì—° ì‹œê°„ì´ ì˜¬ë°”ë¥¸ê°€?
- [ ] ë¡œê·¸ê°€ ì›ë³¸ APKì™€ ìœ ì‚¬í•œê°€?
- [ ] ì„±ëŠ¥ ì´ìŠˆê°€ ì—†ëŠ”ê°€?

---

## 7. ì˜ˆìƒ ì†Œìš” ì‹œê°„

| Phase | ì‘ì—… ë‚´ìš© | ì˜ˆìƒ ì‹œê°„ |
|-------|----------|----------|
| Phase 1 | ë©”ì¸ ë£¨í”„ ì¶”ê°€ | 1ì‹œê°„ |
| Phase 2 | ìƒíƒœë³„ ì§€ì—° ì‹œê°„ | 30ë¶„ |
| Phase 3 | ìƒˆë¡œê³ ì¹¨ ë¡œì§ í†µí•© | 1ì‹œê°„ |
| Phase 4 | Service ë‹¨ìˆœí™” | 30ë¶„ |
| Phase 5 | StateContext ìˆ˜ì • | 30ë¶„ |
| Phase 6 | í…ŒìŠ¤íŠ¸ ë° ë””ë²„ê¹… | 2ì‹œê°„ |
| **í•©ê³„** | | **5.5ì‹œê°„** |

---

## 8. ì£¼ì˜ì‚¬í•­

### âš ï¸ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
```kotlin
// ë‚˜ìœ ì˜ˆ: Runnable ì œê±° ì•ˆ í•¨
handler.postDelayed(runnable, 1000L)
handler.postDelayed(runnable, 1000L)  // ì¤‘ë³µ ë“±ë¡!

// ì¢‹ì€ ì˜ˆ: í•­ìƒ ê¸°ì¡´ ê²ƒ ì œê±°
currentRunnable?.let { handler.removeCallbacks(it) }
currentRunnable = Runnable { ... }
handler.postDelayed(currentRunnable!!, 1000L)
```

### âš ï¸ ë¬´í•œ ë£¨í”„ ì£¼ì˜
```kotlin
// ë‚˜ìœ ì˜ˆ: ì¡°ê±´ ì—†ì´ ì¬ê·€
private fun startMacroLoop() {
    scheduleNext(100L) { startMacroLoop() }  // ë¬´ì¡°ê±´ ì‹¤í–‰!
}

// ì¢‹ì€ ì˜ˆ: isRunning í™•ì¸
private fun startMacroLoop() {
    if (!_isRunning.value) return  // ì¢…ë£Œ ì¡°ê±´!
    scheduleNext(100L) { startMacroLoop() }
}
```

### âš ï¸ rootNode null ì²´í¬
```kotlin
// ë‚˜ìœ ì˜ˆ: nullì¼ ë•Œ í¬ë˜ì‹œ
val rootNode = cachedRootNode!!  // NPE!

// ì¢‹ì€ ì˜ˆ: null ì²˜ë¦¬
val rootNode = cachedRootNode ?: run {
    scheduleNext(100L) { startMacroLoop() }
    return
}
```

---

## 9. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ë¬¸ì œ 1: ë©”ì¸ ë£¨í”„ê°€ ë©ˆì¶¤
**ì¦ìƒ:** ìƒˆë¡œê³ ì¹¨ì´ í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ê³  ë©ˆì¶¤

**ì›ì¸:** `scheduleNext()`ì—ì„œ ì¬ê·€ í˜¸ì¶œ ëˆ„ë½

**í•´ê²°:**
```kotlin
private fun startMacroLoop() {
    // ...
    val delayMs = executeStateMachineOnce(rootNode)
    scheduleNext(delayMs) { startMacroLoop() }  // ì´ ì¤„ í•„ìˆ˜!
}
```

### ë¬¸ì œ 2: ìƒˆë¡œê³ ì¹¨ì´ ë„ˆë¬´ ë¹ ë¦„
**ì¦ìƒ:** 1ì´ˆë§ˆë‹¤ ìƒˆë¡œê³ ì¹¨ë¨

**ì›ì¸:** `calculateRefreshDelay()` ì˜ëª» êµ¬í˜„

**í•´ê²°:**
```kotlin
private fun calculateRefreshDelay(): Long {
    val baseDelay = (refreshDelay * 1000).toLong()  // ì´ˆ â†’ ë°€ë¦¬ì´ˆ
    val randomFactor = 0.9 + kotlin.random.Random.nextDouble(0.0, 0.2)
    return (baseDelay * randomFactor).toLong()
}
```

### ë¬¸ì œ 3: CPU ì‚¬ìš©ë¥  ë†’ìŒ
**ì¦ìƒ:** ë°°í„°ë¦¬ ë¹ ë¥´ê²Œ ì†Œëª¨

**ì›ì¸:** ì§€ì—° ì‹œê°„ì´ ë„ˆë¬´ ì§§ìŒ (1ms ë“±)

**í•´ê²°:**
```kotlin
// ìµœì†Œ ì§€ì—° ì‹œê°„ ë³´ì¥
fun getNextDelay(): Long = 10L.coerceAtLeast(10L)  // ìµœì†Œ 10ms
```

---

## 10. ë‹¤ìŒ ë‹¨ê³„

ì¬ì„¤ê³„ ì™„ë£Œ í›„:
1. ì„±ëŠ¥ ìµœì í™”
2. ì—ëŸ¬ í•¸ë“¤ë§ ê°•í™”
3. ë¡œê¹… ì‹œìŠ¤í…œ ê°œì„ 
4. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€
5. UI ê°œì„ 

---

**ë¬¸ì„œ ë²„ì „:** 1.0
**ì‘ì„±ì¼:** 2026-01-03
**ì‘ì„±ì:** Claude Code Assistant
